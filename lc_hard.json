[
    {
        "desc": "\\nGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\\n",
        "skeleton": "\\ndef trap(self, height: List[int]) -> int:\\n",
        "examples": [],
        "ref": [
            "\\ndef trap(self, height: List[int]) -> int:\\n        left = 0\\n        right = len(height) - 1\\n        left_max = height[left]\\n        right_max = height[right]\\n        water = 0\\n\\n        while left < right:\\n            if left_max < right_max:\\n                left += 1\\n                left_max = max(left_max, height[left])\\n                water += left_max - height[left]\\n            else:\\n                right -= 1\\n                right_max = max(right_max, height[right])\\n                water += right_max - height[right]\\n        \\n        return water\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\\n",
        "skeleton": "\\ndef largestRectangleArea(self, heights: List[int]) -> int:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\\n\\nThe overall run time complexity should be O(log (m+n)).\\n",
        "skeleton": "\\ndef findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven two strings s and t of lengths m and n respectively, return the minimum window \\nsubstring\\n of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \\\"\\\".\\n\\nThe testcases will be generated such that the answer is unique.\\n",
        "skeleton": "\\ndef minWindow(self, s: str, t: str) -> str:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nYou are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\\n\\nReturn the max sliding window.\\n",
        "skeleton": "\\ndef maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nYou are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\\n\\nMerge all the linked-lists into one sorted linked-list and return it.\\n",
        "skeleton": "\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\\n\\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\\n\\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\\n",
        "skeleton": "\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\ndef reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nA path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\\n\\nThe path sum of a path is the sum of the node's values in the path.\\n\\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.\\n",
        "skeleton": "\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\ndef maxPathSum(self, root: Optional[TreeNode]) -> int:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven an integer array nums, return the number of reverse pairs in the array.\\n\\nA reverse pair is a pair (i, j) where:\\n\\n0 <= i < j < nums.length and\\nnums[i] > 2 * nums[j].\\n",
        "skeleton": "\\ndef reversePairs(self, nums: List[int]) -> int:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven an m x n board of characters and a list of strings words, return all words on the board.\\n\\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\\n",
        "skeleton": "\\ndef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nThe n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\\n\\nGiven an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\\n\\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\\n",
        "skeleton": "\\ndef solveNQueens(self, n: int) -> List[List[str]]:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nWe have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].\\n\\nYou're given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.\\n\\nIf you choose a job that ends at time X you will be able to start another job that starts at time X.\\n",
        "skeleton": "\\ndef jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nA transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\\n\\nEvery adjacent pair of words differs by a single letter.\\nEvery si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\\nsk == endWord\\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\\n",
        "skeleton": "\\ndef ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nYou are given a 2D integer array intervals, where intervals[i] = [lefti, righti] describes the ith interval starting at lefti and ending at righti (inclusive). The size of an interval is defined as the number of integers it contains, or more formally righti - lefti + 1.\\n\\nYou are also given an integer array queries. The answer to the jth query is the size of the smallest interval i such that lefti <= queries[j] <= righti. If no such interval exists, the answer is -1.\\n\\nReturn an array containing the answers to the queries.\\n",
        "skeleton": "\\ndef minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nYou are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.\\n\\nAll of the tickets belong to a man who departs from \\\"JFK\\\", thus, the itinerary must begin with \\\"JFK\\\". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.\\n\\nFor example, the itinerary [\\\"JFK\\\", \\\"LGA\\\"] has a smaller lexical order than [\\\"JFK\\\", \\\"LGB\\\"].\\nYou may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.\\n",
        "skeleton": "\\ndef findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nYou are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that point (i, j).\\n\\nThe rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\\n\\nReturn the least time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0).\\n",
        "skeleton": "\\ndef swimInWater(self, grid: List[List[int]]) -> int:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven an m x n integers matrix, return the length of the longest increasing path in matrix.\\n\\nFrom each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).\\n",
        "skeleton": "\\ndef longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven two strings s and t, return the number of distinct subsequences of s which equals t.\\n\\nThe test cases are generated so that the answer fits on a 32-bit signed integer.\\n",
        "skeleton": "\\ndef numDistinct(self, s: str, t: str) -> int:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nYou are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.\\n\\nIf you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.\\n\\nReturn the maximum coins you can collect by bursting the balloons wisely.\\n",
        "skeleton": "\\ndef maxCoins(self, nums: List[int]) -> int:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\\n\\n'.' Matches any single character.\\n'*' Matches zero or more of the preceding element.\\nThe matching should cover the entire input string (not partial).\\n",
        "skeleton": "\\ndef isMatch(self, s: str, p: str) -> bool:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nWrite a program to solve a Sudoku puzzle by filling the empty cells.\\n\\nA sudoku solution must satisfy all of the following rules:\\n\\nEach of the digits 1-9 must occur exactly once in each row.\\nEach of the digits 1-9 must occur exactly once in each column.\\nEach of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\\nThe '.' character indicates empty cells.\\n",
        "skeleton": "\\ndef solveSudoku(self, board: List[List[str]]) -> None:\\n    #Do not return anything, modify board in-place instead.\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven a string s, partition s such that every \\nsubstring of the partition is a palindrome.\\n\\nReturn the minimum cuts needed for a palindrome partitioning of s.\\n",
        "skeleton": "\\ndef minCut(self, s: str) -> int:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nYou are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.\\n\\nFind the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times.\\n\\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\\n",
        "skeleton": "\\ndef maxProfit(self, k: int, prices: List[int]) -> int:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.\\n\\nNote: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().\\n",
        "skeleton": "\\ndef calculate(self, s: str) -> int:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.\\n\\nReturn a list of unique strings that are valid with the minimum number of removals. You may return the answer in any order.\\n",
        "skeleton": "\\ndef removeInvalidParentheses(self, s: str) -> List[str]:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nYou are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.\\n\\nIf you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.\\n\\nReturn the maximum coins you can collect by bursting the balloons wisely.\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven an integer array nums, return an integer array counts where counts[i] is the number of smaller elements to the right of nums[i].\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nYou are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 represent the digits of two numbers. You are also given an integer k.\\n\\nCreate the maximum number of length k <= m + n from digits of the two numbers. The relative order of the digits from the same array must be preserved.\\n\\nReturn an array of the k digits representing the answer.\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.\\n\\nRange sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i <= j.\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array.\\n\\nReturn the minimum number of patches required.\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nYou are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.\\n\\nOne envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\\n\\nReturn the maximum number of envelopes you can Russian doll (i.e., put one inside the other).\\n\\nNote: You cannot rotate an envelope.\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\n frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\\n\\nGiven a list of stones positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit.\\n\\nIf the frog's last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nA password is considered strong if the below conditions are all met:\\n\\nIt has at least 6 characters and at most 20 characters.\\nIt contains at least one lowercase letter, at least one uppercase letter, and at least one digit.\\nIt does not contain three repeating characters in a row (i.e., \\\"Baaabb0\\\" is weak, but \\\"Baaba0\\\" is strong).\\n\\nGiven a string password, return the minimum number of steps required to make password strong. if password is already strong, return 0.\\n\\nIn one step, you can:\\n\\nInsert one character to password,\\nDelete one character from password, or\\nReplace one character of password with another character.\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nSuppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.\\n\\nYou are given n projects where the ith project has a pure profit profits[i] and a minimum capital of capital[i] is needed to start it.\\n\\nInitially, you have w capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\\n\\nPick a list of at most k distinct projects from given projects to maximize your final capital, and return the final maximized capital.\\n\\nThe answer is guaranteed to fit in a 32-bit signed integer.\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nIn the video game Fallout 4, the quest \\\"Road to Freedom\\\" requires players to reach a metal dial called the \\\"Freedom Trail Ring\\\" and use the dial to spell a specific keyword to open the door.\\n\\nGiven a string ring that represents the code engraved on the outer ring and another string key that represents the keyword that needs to be spelled, return the minimum number of steps to spell all the characters in the keyword.\\n\\nInitially, the first character of the ring is aligned at the \\\"12:00\\\" direction. You should spell all the characters in key one by one by rotating ring clockwise or anticlockwise to make each character of the string key aligned at the \\\"12:00\\\" direction and then by pressing the center button.\\n\\nAt the stage of rotating the ring to spell the key character key[i]:\\n\\n1. You can rotate the ring clockwise or anticlockwise by one place, which counts as one step. The final purpose of the rotation is to align one of ring's characters at the \\\"12:00\\\" direction, where this character must equal key[i].\\n2. If the character key[i] has been aligned at the \\\"12:00\\\" direction, press the center button to spell, which also counts as one step. After the pressing, you could begin to spell the next character in the key (next stage). Otherwise, you have finished all the spelling.\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nYou have n super washing machines on a line. Initially, each washing machine has some dresses or is empty.\\n\\nFor each move, you could choose any m (1 <= m <= n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines at the same time.\\n\\nGiven an integer array machines representing the number of dresses in each washing machine from left to right on the line, return the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1.\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven a positive integer n, return the number of the integers in the range [0, n] whose binary representations do not contain consecutive ones.\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nThere are n different online courses numbered from 1 to n. You are given an array courses where courses[i] = [durationi, lastDayi] indicate that the ith course should be taken continuously for durationi days and must be finished before or on lastDayi.\\n\\nYou will start on the 1st day and you cannot take two or more courses simultaneously.\\n\\nReturn the maximum number of courses that you can take.\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nThere is a strange printer with the following two special properties:\\n\\nThe printer can only print a sequence of the same character each time.\\nAt each turn, the printer can print new characters starting from and ending at any place and will cover the original existing characters.\\n\\nGiven a string s, return the minimum number of turns the printer needed to print it.\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nYou are given a string expression representing a Lisp-like expression to return the integer value of.\\n\\nThe syntax for these expressions is given as follows.\\n\\nAn expression is either an integer, let expression, add expression, mult expression, or an assigned variable. Expressions always evaluate to a single integer.\\n(An integer could be positive or negative.)\\nA let expression takes the form \\\"(let v1 e1 v2 e2 ... vn en expr)\\\", where let is always the string \\\"let\\\", then there are one or more pairs of alternating variables and expressions, meaning that the first variable v1 is assigned the value of the expression e1, the second variable v2 is assigned the value of the expression e2, and so on sequentially; and then the value of this let expression is the value of the expression expr.\\nAn add expression takes the form \\\"(add e1 e2)\\\" where add is always the string \\\"add\\\", there are always two expressions e1, e2 and the result is the addition of the evaluation of e1 and the evaluation of e2.\\nA mult expression takes the form \\\"(mult e1 e2)\\\" where mult is always the string \\\"mult\\\", there are always two expressions e1, e2 and the result is the multiplication of the evaluation of e1 and the evaluation of e2.\\nFor this question, we will use a smaller subset of variable names. A variable starts with a lowercase letter, then zero or more lowercase letters or digits. Additionally, for your convenience, the names \\\"add\\\", \\\"let\\\", and \\\"mult\\\" are protected and will never be used as variable names.\\nFinally, there is the concept of scope. When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially. It is guaranteed that every expression is legal. Please see the examples for more details on the scope.\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nThere is a safe protected by a password. The password is a sequence of n digits where each digit can be in the range [0, k - 1].\\n\\nThe safe has a peculiar way of checking the password. When you enter in a sequence, it checks the most recent n digits that were entered each time you type a digit.\\n\\nFor example, the correct password is \\\"345\\\" and you enter in \\\"012345\\\":\\nAfter typing 0, the most recent 3 digits is \\\"0\\\", which is incorrect.\\nAfter typing 1, the most recent 3 digits is \\\"01\\\", which is incorrect.\\nAfter typing 2, the most recent 3 digits is \\\"012\\\", which is incorrect.\\nAfter typing 3, the most recent 3 digits is \\\"123\\\", which is incorrect.\\nAfter typing 4, the most recent 3 digits is \\\"234\\\", which is incorrect.\\nAfter typing 5, the most recent 3 digits is \\\"345\\\", which is correct and the safe unlocks.\\n\\nReturn any string of minimum length that will unlock the safe at some point of entering it.\\n\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nOn an 2 x 3 board, there are five tiles labeled from 1 to 5, and an empty square represented by 0. A move consists of choosing 0 and a 4-directionally adjacent number and swapping it.\\n\\nThe state of the board is solved if and only if the board is [[1,2,3],[4,5,0]].\\n\\nGiven the puzzle board board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1.\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nYou are given an m x n binary grid, where each 1 represents a brick and 0 represents an empty space. A brick is stable if:\\n\\nIt is directly connected to the top of the grid, or\\nAt least one other brick in its four adjacent cells is stable.\\nYou are also given an array hits, which is a sequence of erasures we want to apply. Each time we want to erase the brick at the location hits[i] = (rowi, coli). The brick on that location (if it exists) will disappear. Some other bricks may no longer be stable because of that erasure and will fall. Once a brick falls, it is immediately erased from the grid (i.e., it does not land on other stable bricks).\\n\\nReturn an array result, where each result[i] is the number of bricks that will fall after the ith erasure is applied.\\n\\nNote that an erasure may refer to a location with no brick, and if it does, no bricks drop.\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nYour car starts at position 0 and speed +1 on an infinite number line. Your car can go into negative positions. Your car drives automatically according to a sequence of instructions 'A' (accelerate) and 'R' (reverse):\\n\\nWhen you get an instruction 'A', your car does the following:\\n- position += speed\\n- speed *= 2\\nWhen you get an instruction 'R', your car does the following:\\n- If your speed is positive then speed = -1\\n- otherwise speed = 1\\nYour position stays the same.\\nFor example, after commands \\\"AAR\\\", your car goes to positions 0 --> 1 --> 3 --> 3, and your speed goes to 1 --> 2 --> 4 --> -1.\\n\\nGiven a target position target, return the length of the shortest sequence of instructions to get there.\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nThere are n workers. You are given two integer arrays quality and wage where quality[i] is the quality of the ith worker and wage[i] is the minimum wage expectation for the ith worker.\\n\\nWe want to hire exactly k workers to form a paid group. To hire a group of k workers, we must pay them according to the following rules:\\n\\n1. Every worker in the paid group must be paid at least their minimum wage expectation.\\n2. In the group, each worker's pay must be directly proportional to their quality. This means if a worker's quality is double that of another worker in the group, then they must be paid twice as much as the other worker.\\nGiven the integer k, return the least amount of money needed to form a paid group satisfying the above conditions. Answers within 10-5 of the actual answer will be accepted.\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nA positive integer is magical if it is divisible by either a or b.\\n\\nGiven the three integers n, a, and b, return the nth magical number. Since the answer may be very large, return it modulo 10^9 + 7.\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nYou are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\\n\\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nYou are given two strings stamp and target. Initially, there is a string s of length target.length with all s[i] == '?'.\\n\\nIn one turn, you can place stamp over s and replace every letter in the s with the corresponding letter from stamp.\\n\\nFor example, if stamp = \\\"abc\\\" and target = \\\"abcba\\\", then s is \\\"?????\\\" initially. In one turn you can:\\n- place stamp at index 0 of s to obtain \\\"abc??\\\",\\n- place stamp at index 1 of s to obtain \\\"?abc?\\\", or\\n- place stamp at index 2 of s to obtain \\\"??abc\\\".\\nNote that stamp must be fully contained in the boundaries of s in order to stamp (i.e., you cannot place stamp at index 3 of s).\\n\\nWe want to convert s to target using at most 10 * target.length turns.\\n\\nReturn an array of the index of the left-most letter being stamped at each turn. If we cannot obtain target from s within 10 * target.length turns, return an empty array.\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nYou are given an integer array arr. From some starting index, you can make a series of jumps. The (1st, 3rd, 5th, ...) jumps in the series are called odd-numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even-numbered jumps. Note that the jumps are numbered, not the indices.\\n\\nYou may jump forward from index i to index j (with i < j) in the following way:\\n- During odd-numbered jumps (i.e., jumps 1, 3, 5, ...), you jump to the index j such that arr[i] <= arr[j] and arr[j] is the smallest possible value. If there are multiple such indices j, you can only jump to the smallest such index j.\\n- During even-numbered jumps (i.e., jumps 2, 4, 6, ...), you jump to the index j such that arr[i] >= arr[j] and arr[j] is the largest possible value. If there are multiple such indices j, you can only jump to the smallest such index j.\\n- It may be the case that for some index i, there are no legal jumps.\\nA starting index is good if, starting from that index, you can reach the end of the array (index arr.length - 1) by jumping some number of times (possibly 0 or more than once).\\n\\nReturn the number of good starting indices.\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nThere is a pizza with 3n slices of varying size, you and your friends will take slices of pizza as follows:\\n\\nYou will pick any pizza slice.\\nYour friend Alice will pick the next slice in the anti-clockwise direction of your pick.\\nYour friend Bob will pick the next slice in the clockwise direction of your pick.\\nRepeat until there are no more slices of pizzas.\\n\\nGiven an integer array slices that represent the sizes of the pizza slices in a clockwise direction, return the maximum possible sum of slice sizes that you can pick.\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    }
]