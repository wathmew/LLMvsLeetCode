[
    {
        "desc": "\\nGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\\n",
        "skeleton": "\\ndef trap(self, height: List[int]) -> int:\\n",
        "examples": [],
        "ref": [
            "\\ndef trap(self, height: List[int]) -> int:\\n        left = 0\\n        right = len(height) - 1\\n        left_max = height[left]\\n        right_max = height[right]\\n        water = 0\\n\\n        while left < right:\\n            if left_max < right_max:\\n                left += 1\\n                left_max = max(left_max, height[left])\\n                water += left_max - height[left]\\n            else:\\n                right -= 1\\n                right_max = max(right_max, height[right])\\n                water += right_max - height[right]\\n        \\n        return water\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\\n",
        "skeleton": "\\ndef largestRectangleArea(self, heights: List[int]) -> int:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\\n\\nThe overall run time complexity should be O(log (m+n)).\\n",
        "skeleton": "\\ndef findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven two strings s and t of lengths m and n respectively, return the minimum window \\nsubstring\\n of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \\\"\\\".\\n\\nThe testcases will be generated such that the answer is unique.\\n",
        "skeleton": "\\ndef minWindow(self, s: str, t: str) -> str:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nYou are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\\n\\nReturn the max sliding window.\\n",
        "skeleton": "\\ndef maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nYou are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\\n\\nMerge all the linked-lists into one sorted linked-list and return it.\\n",
        "skeleton": "\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\\n\\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\\n\\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\\n",
        "skeleton": "\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\ndef reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nA path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\\n\\nThe path sum of a path is the sum of the node's values in the path.\\n\\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.\\n",
        "skeleton": "\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\ndef maxPathSum(self, root: Optional[TreeNode]) -> int:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven an integer array nums, return the number of reverse pairs in the array.\\n\\nA reverse pair is a pair (i, j) where:\\n\\n0 <= i < j < nums.length and\\nnums[i] > 2 * nums[j].\\n",
        "skeleton": "\\ndef reversePairs(self, nums: List[int]) -> int:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven an m x n board of characters and a list of strings words, return all words on the board.\\n\\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\\n",
        "skeleton": "\\ndef findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nThe n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\\n\\nGiven an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\\n\\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\\n",
        "skeleton": "\\ndef solveNQueens(self, n: int) -> List[List[str]]:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nWe have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].\\n\\nYou're given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.\\n\\nIf you choose a job that ends at time X you will be able to start another job that starts at time X.\\n",
        "skeleton": "\\ndef jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nA transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\\n\\nEvery adjacent pair of words differs by a single letter.\\nEvery si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\\nsk == endWord\\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\\n",
        "skeleton": "\\ndef ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nYou are given a 2D integer array intervals, where intervals[i] = [lefti, righti] describes the ith interval starting at lefti and ending at righti (inclusive). The size of an interval is defined as the number of integers it contains, or more formally righti - lefti + 1.\\n\\nYou are also given an integer array queries. The answer to the jth query is the size of the smallest interval i such that lefti <= queries[j] <= righti. If no such interval exists, the answer is -1.\\n\\nReturn an array containing the answers to the queries.\\n",
        "skeleton": "\\ndef minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nYou are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.\\n\\nAll of the tickets belong to a man who departs from \\\"JFK\\\", thus, the itinerary must begin with \\\"JFK\\\". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.\\n\\nFor example, the itinerary [\\\"JFK\\\", \\\"LGA\\\"] has a smaller lexical order than [\\\"JFK\\\", \\\"LGB\\\"].\\nYou may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.\\n",
        "skeleton": "\\ndef findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nYou are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that point (i, j).\\n\\nThe rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\\n\\nReturn the least time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0).\\n",
        "skeleton": "\\ndef swimInWater(self, grid: List[List[int]]) -> int:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven an m x n integers matrix, return the length of the longest increasing path in matrix.\\n\\nFrom each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).\\n",
        "skeleton": "\\ndef longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven two strings s and t, return the number of distinct subsequences of s which equals t.\\n\\nThe test cases are generated so that the answer fits on a 32-bit signed integer.\\n",
        "skeleton": "\\ndef numDistinct(self, s: str, t: str) -> int:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nYou are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.\\n\\nIf you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.\\n\\nReturn the maximum coins you can collect by bursting the balloons wisely.\\n",
        "skeleton": "\\ndef maxCoins(self, nums: List[int]) -> int:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\\n\\n'.' Matches any single character.\\n'*' Matches zero or more of the preceding element.\\nThe matching should cover the entire input string (not partial).\\n",
        "skeleton": "\\ndef isMatch(self, s: str, p: str) -> bool:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nWrite a program to solve a Sudoku puzzle by filling the empty cells.\\n\\nA sudoku solution must satisfy all of the following rules:\\n\\nEach of the digits 1-9 must occur exactly once in each row.\\nEach of the digits 1-9 must occur exactly once in each column.\\nEach of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\\nThe '.' character indicates empty cells.\\n",
        "skeleton": "\\ndef solveSudoku(self, board: List[List[str]]) -> None:\\n    #Do not return anything, modify board in-place instead.\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven a string s, partition s such that every \\nsubstring of the partition is a palindrome.\\n\\nReturn the minimum cuts needed for a palindrome partitioning of s.\\n",
        "skeleton": "\\ndef minCut(self, s: str) -> int:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nYou are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.\\n\\nFind the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times.\\n\\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\\n",
        "skeleton": "\\ndef maxProfit(self, k: int, prices: List[int]) -> int:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.\\n\\nNote: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().\\n",
        "skeleton": "\\ndef calculate(self, s: str) -> int:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\nGiven a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.\\n\\nReturn a list of unique strings that are valid with the minimum number of removals. You may return the answer in any order.\\n",
        "skeleton": "\\ndef removeInvalidParentheses(self, s: str) -> List[str]:\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\n\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\n\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\n\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\n\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\n\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\n\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\n\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\n\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\n\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\n\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\n\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\n\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\n\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\n\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\n\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\n\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\n\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\n\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\n\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\n\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\n\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\n\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\n\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\n\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    },
    {
        "desc": "\\n\\n",
        "skeleton": "\\n\\n",
        "examples": [],
        "ref": [
            "\\n\\n"
        ],
        "test": {
            "input": [],
            "output": []
        }
    }
]