from collections import Counter

class Solution:
    def strongPasswordChecker(self, password: str) -> int:
        # Check if password is already strong
        if len(password) < 6 or len(password) > 20:
            return 0

        # Check for lowercase, uppercase, and digit
        has_lower = any(char.islower() for char in password)
        has_upper = any(char.isupper() for char in password)
        has_digit = any(char.isdigit() for char in password)

        # Check for consecutive repeats
        consecutive_repeats = [len(list(g)) for _, g in groupby(password)]
        long_repeats = [length for length in consecutive_repeats if length > 2]

        # If password is already strong, return 0
        if not has_lower and not has_upper and not has_digit:
            return 0

        # If password length is less than 6, return the difference
        if len(password) < 6:
            return max(6 - len(password), len(password) - 6)

        # If password length is more than 20, heapify and pop to find the longest sequence of non-repeating characters
        if len(password) > 20:
            long_repeats = [(length % 3, length) for length in long_repeats]
            heapify(long_repeats)
            for _ in range(len(password) - 20):
                if not long_repeats:
                    break
                _, length = heappop(long_repeats)
                if length > 3:
                    heappush(long_repeats, ((length - 1) % 3, length - 1))
            long_repeats = [length for _, length in long_repeats]

        # Calculate the minimum number of steps required
        return max(len(password) - 20 + max(0, len(long_repeats) // 3) + max(0, len(password) - 20))
