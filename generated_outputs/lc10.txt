def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
    """
    Given an m x n board of characters and a list of strings words, return all words on the board.
    
    Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring.
    The same letter cell may not be used more than once in a word.
    
    :param board: A 2D list of characters representing the board
    :type board: List[List[str]]
    :param words: A list of strings to find in the board
    :type words: List[str]
    :return: A list of strings that are found in the board
    :rtype: List[str]
    """
    def exist(word: str) -> bool:
        """
        Helper function to check if a word exists in the board.
        
        :param word: The word to check
        :type word: str
        :return: True if the word exists, False otherwise
        :rtype: bool
        """
        if len(word) > len(board[0] * len(board):  # Check if word is too long
            return False
        def backtracking(i: int, j: int, word_idx: int) -> bool:
            """
            Recursive function to perform backtracking.
            
            :param i: The current row index
            :param j: The current column index
            :param word_idx: The current index in the word
            :type i: int
            :type j: int
            :type word_idx: int
            :return: True if the word is found, False otherwise
            :rtype: bool
            """
            if word_idx == len(word):  # If the word is found, return True
                return True
            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):  # If out of bounds, return False
                return False
            elif board[i][j]!= word[word_idx]:  # If the current letter does not match, return False
                return False
            buff, board[i][j] = board[i][j], '#'  # Mark the current cell as visited
            res = (backtracking(i + 1, j, word_idx + 1) or  # Try moving up
                   backtracking(i - 1, j, word_idx + 1) or  # Try moving left
                   backtracking(i, j + 1, word_idx + 1) or  # Try moving down
                   backtracking(i, j - 1, word_idx + 1))  # Try moving right
            board[i][j] = buff  # Unmark the current cell
            return res
        for i in range(len(board)):  # Try each cell in the board
            for j in range(len(board[i])):  # Try each cell in the row
                if backtracking(i, j, 0):  # If the word is found, return True
                    return True
        return False
    res = []  # Initialize the result list
    for word in words:  # Try each word in the list
        if exist(word):  # If the word exists, add it to the result list
            res.append(word)
    return res
